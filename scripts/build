#!/usr/bin/env python3

import argparse
import subprocess
import multiprocessing
import shutil
import os
import sys


def command_exists(cmd):
    return shutil.which(cmd) is not None


def get_directory(is_release, cpu_only, forced):
    if forced is not None:
        return forced
    out = "release" if is_release else "debug"
    if cpu_only:
        out += "_cpu_only"

    return out


def get_builder(page, lolcat, threads, cuda_archs):
    def build(is_release,
              cpu_only,
              directory,
              additional_gen_args=None,
              additional_build_args=None,
              skip_build=False):
        extra_cmds = []

        if lolcat:
            if command_exists("lolcat"):
                extra_cmds.append(["lolcat", "--force"])

        if page:
            # if command_exists("bat"):
            #     extra_cmds.append(["bat", "-p"])
            if command_exists("less"):
                extra_cmds.append(["less", "-R"])
            elif command_exists("more"):
                extra_cmds.append(["more"])

        build_type = "RelWithDebInfo" if is_release else "Debug"

        unbuffer_cmd = [
            "unbuffer", "cmake"
        ] if command_exists("unbuffer") and page else ["cmake"]

        if additional_gen_args is None:
            additional_gen_args = []

        if additional_build_args is None:
            additional_build_args = []

        gen_cmd = unbuffer_cmd + [
            "-H.", "-B" + directory, "-DCMAKE_BUILD_TYPE=" + build_type,
            "-DCMAKE_CUDA_ARCHITECTURES=" + cuda_archs
        ] + additional_gen_args
        if cpu_only:
            gen_cmd += ["-DCPU_ONLY=ON", "-DCPU_GPU=OFF"]
        else:
            gen_cmd += ["-DCPU_ONLY=OFF", "-DCPU_GPU=ON"]

        build_cmd = unbuffer_cmd + ["--build", directory, "-j",
                                    str(threads)] + additional_build_args

        def runner(cmd):
            cmds = [cmd] + extra_cmds

            processes = []
            cmd_process = None
            for i, c in enumerate(cmds):
                last = i == len(cmds) - 1
                first = cmd_process is None
                cmd_process = subprocess.Popen(
                    c,
                    stdout=None if last else subprocess.PIPE,
                    stderr=None if last else subprocess.STDOUT,
                    stdin=None if first else cmd_process.stdout)
                processes.append(cmd_process)

            for process in reversed(processes):
                process.wait()
                if process.returncode != 0:
                    sys.exit(process.returncode)

        runner(gen_cmd)
        if not skip_build:
            runner(build_cmd)

    return build


def build_default_command_parser(description):
    parser = argparse.ArgumentParser(description=description)
    parser.add_argument('--release', action='store_true')
    parser.add_argument('--cpu-only',
                        dest='cpu_only',
                        action='store_true',
                        help='only build for the cpu')
    parser.add_argument('--no-cpu-only',
                        dest='cpu_only',
                        action='store_false',
                        help='build for the cpu and gpu')

    return parser


def build_command(builder, remaining_args, forced_directory):
    parser = build_default_command_parser('build project')
    args = parser.parse_args(remaining_args)
    builder(args.release, args.cpu_only,
            get_directory(args.release, args.cpu_only, forced_directory))


def run_command(builder, remaining_args, forced_directory):
    parser = build_default_command_parser('run executable')
    parser.add_argument('executable', help='bin to run')
    parser.add_argument('executable_args', nargs=argparse.REMAINDER)
    args = parser.parse_args(remaining_args)
    directory = get_directory(args.release, args.cpu_only, forced_directory)
    builder(args.release, args.cpu_only, directory)
    try:
        subprocess.run([os.path.join(directory, args.executable)] +
                       args.executable_args,
                       check=True)
    except subprocess.CalledProcessError as e:
        sys.exit(e.returncode)


def test_command(builder, remaining_args, forced_directory):
    parser = build_default_command_parser('run all tests')
    args = parser.parse_args(remaining_args)
    builder(args.release,
            args.cpu_only,
            get_directory(args.release, args.cpu_only, forced_directory),
            additional_gen_args=["-DBUILD_TESTING=ON"],
            additional_build_args=["--target", "check"])


def bench_command(builder, remaining_args, forced_directory):
    parser = build_default_command_parser('run benchmarks')
    parser.add_argument('executable', help='benchmark to run')
    parser.add_argument('executable_args', nargs=argparse.REMAINDER)
    args = parser.parse_args(remaining_args)
    directory = get_directory(args.release, args.cpu_only, forced_directory)
    builder(args.release,
            args.cpu_only,
            directory,
            additional_gen_args=["-DBUILD_BENCHMARKS=ON"])
    subprocess.run([os.path.join(directory, args.executable)] +
                   args.executable_args,
                   check=True)


def cc_command(builder, _, forced_directory):
    directory = get_directory(False, False, forced_directory)
    builder(False,
            False,
            directory,
            additional_gen_args=["-DCMAKE_EXPORT_COMPILE_COMMANDS=YES"],
            skip_build=True)
    if os.path.exists("compile_commands.json"):
        print("compile_commands.json exists - not overriding")
    else:
        os.symlink(os.path.join(directory, "compile_commands.json"),
                   "compile_commands.json")


# def check_command(builder, _):
#     builder(False, "check", additional_gen_args=["-DSYNTAX_ONLY=ON"])


def clean_command(_builder, remaining_args, forced_directory):
    parser = build_default_command_parser('clean project')
    args = parser.parse_args(remaining_args)
    shutil.rmtree(get_directory(args.release, args.cpu_only, forced_directory),
                  ignore_errors=True)


def main():
    name = "build"

    main_parser = argparse.ArgumentParser(
        description='Simple cmake wrapper',
        usage='''{} [OPTIONS] <COMMAND> [<SUBOPTIONS>]
'''.format(name))
    main_parser.add_argument('command', help='subcommand to run')
    main_parser.add_argument('--cuda-archs',
                             default='75',
                             help='cuda architectures to build')
    main_parser.add_argument('-p',
                             '--paginate',
                             action='store_true',
                             help='page output')
    main_parser.add_argument('-P',
                             '--no-pager',
                             action='store_true',
                             help="don't page output")
    main_parser.add_argument('-l',
                             '--lolcat',
                             action='store_true',
                             help='lolcat output')
    main_parser.add_argument('-j',
                             '--threads',
                             type=int,
                             default=multiprocessing.cpu_count(),
                             help='set num threads')
    main_parser.add_argument('--directory', help='force specific directory')

    args, unknown = main_parser.parse_known_args()
    commands = {
        "build": build_command,
        "run": run_command,
        "test": test_command,
        "bench": bench_command,
        "compile_commands": cc_command,
        # "check": check_command,
        "clean": clean_command,
    }
    page = args.paginate and not args.no_pager
    try:
        cmd = commands[args.command]
    except KeyError:
        print("{0}: '{1}' is not a command. See '{0} --help'.".format(
            name, args.command))
        sys.exit(1)
    cmd(get_builder(page, args.lolcat, args.threads, args.cuda_archs), unknown,
        args.directory)


if __name__ == "__main__":
    main()
