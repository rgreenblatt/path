#!/usr/bin/env python3

import argparse
import subprocess
import multiprocessing
import shutil
import os
import sys


def command_exists(cmd):
    return shutil.which(cmd) is not None


def get_directory(is_release, forced):
    if forced is not None:
        return forced

    return "release" if is_release else "debug"


def get_builder(page, lolcat, threads, cpu_only_build, cuda_archs):
    def build(is_release,
              directory,
              additional_gen_args=None,
              additional_build_args=None,
              skip_build=False):
        extra_cmds = []

        if lolcat:
            if command_exists("lolcat"):
                extra_cmds.append(["lolcat", "--force"])

        if page:
            if command_exists("bat"):
                extra_cmds.append(["bat", "-p"])
            elif command_exists("less"):
                extra_cmds.append(["less"])
            elif command_exists("more"):
                extra_cmds.append(["more"])

        build_type = "RelWithDebInfo" if is_release else "Debug"

        unbuffer_cmd = [
            "unbuffer", "cmake"
        ] if command_exists("unbuffer") and page else ["cmake"]

        if additional_gen_args is None:
            additional_gen_args = []

        if additional_build_args is None:
            additional_build_args = []

        gen_cmd = unbuffer_cmd + [
            "-H.", "-B" + directory, "-DCMAKE_BUILD_TYPE=" + build_type,
            "-DCMAKE_CUDA_ARCHITECTURES=" + cuda_archs
        ] + additional_gen_args
        if cpu_only_build:
            gen_cmd += ["-DCPU_ONLY_BUILD=ON", "-DCPU_GPU_BUILD=OFF"]
        else:
            gen_cmd += ["-DCPU_ONLY_BUILD=OFF", "-DCPU_GPU_BUILD=ON"]

        build_cmd = unbuffer_cmd + ["--build", directory, "-j",
                                    str(threads)] + additional_build_args

        def runner(cmd):
            cmds = [cmd] + extra_cmds

            cmd_process = None
            for i, c in enumerate(cmds):
                cmd_process = subprocess.Popen(
                    c,
                    stdout=None if i == len(cmds) - 1 else subprocess.PIPE,
                    stdin=None if cmd_process is None else cmd_process.stdout)

            cmd_process.wait()

        runner(gen_cmd)
        if not skip_build:
            runner(build_cmd)

    return build


def build_command(builder, remaining_args, forced_directory):
    parser = argparse.ArgumentParser(description='build project')
    parser.add_argument('--release', action='store_true')
    args = parser.parse_args(remaining_args)
    builder(args.release, get_directory(args.release, forced_directory))


def run_command(builder, remaining_args, forced_directory):
    parser = argparse.ArgumentParser(description='run executable')
    parser.add_argument('--release', action='store_true')
    parser.add_argument('executable', help='bin to run')
    parser.add_argument('executable_args', nargs=argparse.REMAINDER)
    args = parser.parse_args(remaining_args)
    directory = get_directory(args.release, forced_directory)
    builder(args.release, directory)
    subprocess.run([os.path.join(directory, args.executable)] +
                   args.executable_args)


def test_command(builder, remaining_args, forced_directory):
    parser = argparse.ArgumentParser(description='run all tests')
    parser.add_argument('--release', action='store_true')
    args = parser.parse_args(remaining_args)
    builder(args.release,
            get_directory(args.release, forced_directory),
            additional_gen_args=["-DBUILD_TESTING=ON"],
            additional_build_args=["--target", "check"])


def bench_command(builder, remaining_args, forced_directory):
    parser = argparse.ArgumentParser(description='run benchmarks')
    parser.add_argument('--release', action='store_true')
    parser.add_argument('executable', help='benchmark to run')
    parser.add_argument('executable_args', nargs=argparse.REMAINDER)
    args = parser.parse_args(remaining_args)
    directory = get_directory(args.release, forced_directory)
    builder(args.release,
            directory,
            additional_gen_args=["-DBUILD_BENCHMARKS=ON"])
    subprocess.run([os.path.join(directory, args.executable)] +
                   args.executable_args)


def cc_command(builder, _, forced_directory):
    directory = get_directory(False, forced_directory)
    builder(False,
            directory,
            additional_gen_args=["-DCMAKE_EXPORT_COMPILE_COMMANDS=YES"],
            skip_build=True)
    if os.path.exists("compile_commands.json"):
        print("compile_commands.json exists - not overriding")
    else:
        os.symlink(os.path.join(directory, "compile_commands.json"),
                   "compile_commands.json")


# def check_command(builder, _):
#     builder(False, "check", additional_gen_args=["-DSYNTAX_ONLY=ON"])


def clean_command(_builder, remaining_args, forced_directory):
    parser = argparse.ArgumentParser(description='clean project')
    parser.add_argument('--release', action='store_true')
    args = parser.parse_args(remaining_args)
    shutil.rmtree(get_directory(args.release, forced_directory))


def main():
    name = "build"

    main_parser = argparse.ArgumentParser(
        description='Simple cmake wrapper',
        usage='''{} [OPTIONS] <COMMAND> [<SUBOPTIONS>]
'''.format(name))
    main_parser.add_argument('command', help='subcommand to run')
    main_parser.add_argument('--cuda-archs',
                             default='75',
                             help='cuda architectures to build')
    main_parser.add_argument('-p',
                             '--paginate',
                             action='store_true',
                             help='page output')
    main_parser.add_argument('-P',
                             '--no-pager',
                             action='store_true',
                             help="don't page output")
    main_parser.add_argument('-l',
                             '--lolcat',
                             action='store_true',
                             help='lolcat output')
    main_parser.add_argument('-j',
                             '--threads',
                             type=int,
                             default=multiprocessing.cpu_count(),
                             help='set num threads')
    main_parser.add_argument('--directory', help='force specific directory')
    main_parser.add_argument('--cpu-only-build',
                             dest='cpu_only_build',
                             action='store_true',
                             help='only build for the cpu')
    main_parser.add_argument('--no-cpu-only-build',
                             dest='cpu_only_build',
                             action='store_false',
                             help='build for the cpu and gpu')

    args, unknown = main_parser.parse_known_args()
    commands = {
        "build": build_command,
        "run": run_command,
        "test": test_command,
        "bench": bench_command,
        "compile_commands": cc_command,
        # "check": check_command,
        "clean": clean_command,
    }
    page = args.paginate and not args.no_pager
    try:
        cmd = commands[args.command]
    except KeyError:
        print("{0}: '{1}' is not a command. See '{0} --help'.".format(
            name, args.command))
        sys.exit(1)
    cmd(
        get_builder(page, args.lolcat, args.threads, args.cpu_only_build,
                    args.cuda_archs), unknown, args.directory)


if __name__ == "__main__":
    main()
